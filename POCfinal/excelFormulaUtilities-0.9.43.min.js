var formulaObj = {};
var FR = require('formulajs');
(function() {
    //"undefined" === typeof window && (window = root);
    
    formulaObj.excelFormulaUtilities = {};
    var m = formulaObj.excelFormulaUtilities.core = {};
    formulaObj.excelFormulaUtilities.string = formulaObj.excelFormulaUtilities.string || {};
    formulaObj.excelFormulaUtilities.string.formatStr = function(l) {
        for (var m = l, n = 1; n < arguments.length; n++) m = m.replace(new RegExp("\\{{1}" + (n - 1).toString() + "{1}\\}{1}", "g"), arguments[n]);
        return m
    };
    formulaObj.excelFormulaUtilities.string.trim = function(l) {
        return l.replace(/^\s|\s$/,
            "")
    };
    formulaObj.excelFormulaUtilities.string.trim = function(l) {
        return l.replace(/^(?:\s|&nbsp;|<\s*br\s*\/*\s*>)*|(?:\s|&nbsp;|<\s*br\s*\/*\s*>)*$/, "")
    };
    var C = m.isFunction = function(l) {
            return "function" === typeof l
        },
        y = m.isArray = function(l) {
            return "object" === typeof l && l.length
        },
        G = m.isWindow = function() {
            return obj && "object" === typeof obj && "setInterval" in obj
        },
        z = m.isPlainObject = function(l) {
            if (!l || "object" !== typeof l || l.nodeType || G(l) || l.constructor && !hasOwnProperty.call(l, "constructor") && !hasOwnProperty.call(l.constructor.prototype,
                    "isPrototypeOf")) return !1;
            for (var m in l);
            return void 0 === m || hasOwnProperty.call(l, m)
        };
    m.extend = function() {
        var l, x, n, t, q, r = arguments[0] || {},
            k = 1,
            A = arguments.length,
            p = !1;
        "boolean" === typeof r && (p = r, r = arguments[1] || {}, k = 2);
        "object" === typeof r || C(r) || (r = {});
        A === k && (r = this, --k);
        for (; k < A; k++)
            if (null != (l = arguments[k]))
                for (x in l) n = r[x], t = l[x], r !== t && (p && t && (z(t) || (q = y(t))) ? (q ? (q = !1, n = n && y(n) ? n : []) : n = n && z(n) ? n : {}, r[x] = m.extend(p, n, t)) : void 0 !== t && (r[x] = t));
        return r
    }
})();
(function(m) {
    function C(d, c, b) {
        this.value = d;
        this.type = c;
        this.subtype = b
    }

    function y() {
        this.items = [];
        this.add = function(d, c, b) {
            b || (b = "");
            d = new C(d, c, b);
            this.addRef(d);
            return d
        };
        this.addRef = function(d) {
            this.items.push(d)
        };
        this.index = -1;
        this.reset = function() {
            this.index = -1
        };
        this.BOF = function() {
            return 0 >= this.index
        };
        this.EOF = function() {
            return this.index >= this.items.length - 1
        };
        this.moveNext = function() {
            if (this.EOF()) return !1;
            this.index += 1;
            return !0
        };
        this.current = function() {
            return -1 === this.index ? null : this.items[this.index]
        };
        this.next = function() {
            return this.EOF() ? null : this.items[this.index + 1]
        };
        this.previous = function() {
            return 1 > this.index ? null : this.items[this.index - 1]
        }
    }

    function G() {
        this.items = [];
        this.push = function(d) {
            this.items.push(d)
        };
        this.pop = function(d) {
            var c = this.items.pop();
            return new C(d || "", c.type, u)
        };
        this.token = function() {
            return 0 < this.items.length ? this.items[this.items.length - 1] : null
        };
        this.value = function() {
            return this.token() ? this.token().value.toString() : ""
        };
        this.type = function() {
            return this.token() ? this.token().type.toString() :
                ""
        };
        this.subtype = function() {
            return this.token() ? this.token().subtype.toString() : ""
        }
    }

    function z(d) {
        for (var c = new y, b = new G, e = 0, f = function() {
                return d.substr(e, 1)
            }, a = "", h = !1, g = !1, k = !1, l = !1, n = /^[1-9]{1}(\.[0-9]+)?E{1}$/; 0 < d.length;)
            if (" " === d.substr(0, 1)) d = d.substr(1);
            else {
                "=" === d.substr(0, 1) && (d = d.substr(1));
                break
            }
        for (; !(e >= d.length);)
            if (h) '"' === f() ? '"' === d.substr(e + 1, 1) ? (a += '"', e += 1) : (h = !1, c.add(a, p, P), a = "") : a += f(), e += 1;
            else if (g) "'" === f() ? "'" === d.substr(e + 1, 1) ? (a += "'", e += 1) : g = !1 : a += f(), e += 1;
        else if (k) "]" ===
            f() && (k = !1), a += f(), e += 1;
        else if (l) a += f(), e += 1, -1 !== ",#NULL!,#DIV/0!,#VALUE!,#REF!,#NAME?,#NUM!,#N/A,".indexOf("," + a + ",") && (l = !1, c.add(a, p, Q), a = "");
        else if (-1 !== "+-".indexOf(f()) && 1 < a.length && a.match(n)) a += f(), e += 1;
        else if ('"' === f()) 0 < a.length && (c.add(a, D), a = ""), h = !0, e += 1;
        else if ("'" === f()) 0 < a.length && (c.add(a, D), a = ""), g = !0, e += 1;
        else if ("[" === f()) k = !0, a += f(), e += 1;
        else if ("#" === f()) 0 < a.length && (c.add(a, D), a = ""), l = !0, a += f(), e += 1;
        else if ("{" === f()) 0 < a.length && (c.add(a, D), a = ""), b.push(c.add("ARRAY", s,
            v)), b.push(c.add("ARRAYROW", s, v)), e += 1;
        else if (";" === f()) m.excelFormulaUtilities.isEu ? (0 < a.length && (c.add(a, p), a = ""), b.type() !== s ? c.add(f(), w, K) : c.add(f(), E)) : (0 < a.length && (c.add(a, p), a = ""), c.addRef(b.pop()), c.add(",", E), b.push(c.add("ARRAYROW", s, v))), e += 1;
        else if ("}" === f()) 0 < a.length && (c.add(a, p), a = ""), c.addRef(b.pop("ARRAYROWSTOP")), c.addRef(b.pop("ARRAYSTOP")), e += 1;
        else if (" " === f())
            for (0 < a.length && (c.add(a, p), a = ""), c.add("", L), e += 1;
                " " === f() && !(e >= d.length);) e += 1;
        else -1 !== ",>=,<=,<>,".indexOf("," +
            d.substr(e, 2) + ",") ? (0 < a.length && (c.add(a, p), a = ""), c.add(d.substr(e, 2), w, H), e += 2) : (-1 !== "+-*/^&=><".indexOf(f()) ? (0 < a.length && (c.add(a, p), a = ""), c.add(f(), w)) : -1 !== "%".indexOf(f()) ? (0 < a.length && (c.add(a, p), a = ""), c.add(f(), I)) : "(" === f() ? 0 < a.length ? (b.push(c.add(a, s, v)), a = "") : b.push(c.add("", B, v)) : "," !== f() || m.excelFormulaUtilities.isEu ? ")" === f() ? (0 < a.length && (c.add(a, p), a = ""), c.addRef(b.pop())) : a += f() : (0 < a.length && (c.add(a, p), a = ""), b.type() !== s ? c.add(f(), w, K) : c.add(f(), E)), e += 1);
        0 < a.length && c.add(a,
            p);
        for (b = new y; c.moveNext();) a = c.current(), a.type.toString() === L ? (f = (f = (f = c.BOF() || c.EOF()) && (c.previous().type.toString() === s && c.previous().subtype.toString() === u || c.previous().type.toString() === B && c.previous().subtype.toString() === u || c.previous().type.toString() === p)) && (c.next().type.toString() === s && c.next().subtype.toString() === v || c.next().type.toString() === B && c.next().subtype.toString() === v || c.next().type.toString() === p)) && b.add(a.value.toString(), w, R) : b.addRef(a);
        for (; b.moveNext();) a = b.current(),
            a.type.toString() === w && "-" === a.value.toString() ? b.BOF() ? a.type = M.toString() : b.previous().type.toString() === s && b.previous().subtype.toString() === u || b.previous().type.toString() === B && b.previous().subtype.toString() === u || b.previous().type.toString() === I || b.previous().type.toString() === p ? a.subtype = J.toString() : a.type = M.toString() : a.type.toString() === w && "+" === a.value.toString() ? b.BOF() ? a.type = A.toString() : b.previous().type.toString() === s && b.previous().subtype.toString() === u || b.previous().type.toString() ===
            B && b.previous().subtype.toString() === u || b.previous().type.toString() === I || b.previous().type.toString() === p ? a.subtype = J.toString() : a.type = A.toString() : a.type.toString() === w && 0 === a.subtype.length ? -1 !== "<>=".indexOf(a.value.substr(0, 1)) ? a.subtype = H.toString() : a.subtype = "&" === a.value.toString() ? S.toString() : J.toString() : a.type.toString() === p && 0 === a.subtype.length ? isNaN(parseFloat(a.value)) ? a.subtype = "TRUE" === a.value.toString() || "FALSE" === a.value.toString() ? H.toString() : N.toString() : a.subtype = T.toString() :
            a.type.toString() === s && "@" === a.value.substr(0, 1) && (a.value = a.value.substr(1).toString());
        b.reset();
        for (c = new y; b.moveNext();) b.current().type.toString() !== A && c.addRef(b.current());
        c.reset();
        return c
    }

    function l(d, c) {
        if (!RegExp("[a-z]+[0-9]+:[a-z]+[0-9]+", "gi").test(d)) throw "This is not a valid range: " + d;
        var b = d.split(":"),
            e = parseInt(b[0].match(/[0-9]+/gi)[0]),
            f = b[0].match(/[A-Z]+/gi)[0],
            a = F(f);
        endRow = parseInt(b[1].match(/[0-9]+/gi)[0]);
        endCol = b[1].match(/[A-Z]+/gi)[0];
        endColDec = F(endCol);
        totalRows =
            endRow - e + 1;
        totalCols = F(endCol) - F(f) + 1;
        curCol = 0;
        curRow = 1;
        for (retStr = curCell = ""; curRow <= totalRows; curRow += 1) {
            for (; curCol < totalCols; curCol += 1) curCell = U(a + curCol) + "" + (e + curRow - 1), retStr += curCell + (curRow === totalRows && curCol === totalCols - 1 ? "" : c);
            curCol = 0
        }
        return retStr
    }

    function x(d, c, b, e, f, a) {
        a = void 0 === typeof a || null === a ? null : a;
        var h = function(a) {
                return a.replace(/\{\{token\}\}/gi, "{0}").replace(/\{\{autoindent\}\}/gi, "{1}").replace(/\{\{autolinebreak\}\}/gi, "{2}")
            },
            g = "",
            g = "text" === d.subtype || "text" === d.type ?
            d.value.toString() : (0 === d.value.length ? " " : d.value.toString()).split(" ").join("").toString();
        if ("function" === typeof f && (f = f(g, d, b, e), g = f.tokenString, !f.useTemplate)) return g;
        switch (d.type) {
            case "function":
                switch (d.value) {
                    case "ARRAY":
                        g = q(h(c.tmplFunctionStartArray), g, b, e);
                        break;
                    case "ARRAYROW":
                        g = q(h(c.tmplFunctionStartArrayRow), g, b, e);
                        break;
                    default:
                        g = "start" === d.subtype.toString() ? q(h(c.tmplFunctionStart), g, b, e) : q(h(c.tmplFunctionStop), g, b, e)
                }
                break;
            case "operand":
                switch (d.subtype.toString()) {
                    case "error":
                        g =
                            q(h(c.tmplOperandError), g, b, e);
                        break;
                    case "range":
                        g = q(h(c.tmplOperandRange), g, b, e);
                        break;
                    case "number":
                        g = q(h(c.tmplOperandNumber), g, b, e);
                        break;
                    case "text":
                        g = q(h(c.tmplOperandText), g, b, e);
                        break;
                    case "argument":
                        g = q(h(c.tmplArgument), g, b, e)
                }
                break;
            case "operator-infix":
            case "logical":
                g = q(h(c.tmplOperandLogical), g, b, e);
                break;
            case "argument":
                g = "argument" !== a.type ? q(h(c.tmplArgument), g, b, e) : q(h("{{autoindent}}" + c.tmplArgument), g, b, e);
                break;
            case "subexpression":
                g = "start" === d.subtype.toString() ? q(h(c.tmplSubexpressionStart),
                    g, b, e) : q(h(c.tmplSubexpressionStop), g, b, e)
        }
        return g
    }
    var n = m.excelFormulaUtilities = m.excelFormulaUtilities || {},
        t = m.excelFormulaUtilities.core,
        q = m.excelFormulaUtilities.string.formatStr,
        r = m.excelFormulaUtilities.string.trim,
        k = {},
        A = k.TOK_TYPE_NOOP = "noop",
        p = k.TOK_TYPE_OPERAND = "operand",
        s = k.TOK_TYPE_FUNCTION = "function",
        B = k.TOK_TYPE_SUBEXPR = "subexpression",
        E = k.TOK_TYPE_ARGUMENT = "argument",
        M = k.TOK_TYPE_OP_PRE = "operator-prefix",
        w = k.TOK_TYPE_OP_IN = "operator-infix",
        I = k.TOK_TYPE_OP_POST = "operator-postfix",
        L =
        k.TOK_TYPE_WSPACE = "white-space",
        D = k.TOK_TYPE_UNKNOWN = "unknown",
        v = k.TOK_SUBTYPE_START = "start",
        u = k.TOK_SUBTYPE_STOP = "stop",
        P = k.TOK_SUBTYPE_TEXT = "text",
        T = k.TOK_SUBTYPE_NUMBER = "number",
        H = k.TOK_SUBTYPE_LOGICAL = "logical",
        Q = k.TOK_SUBTYPE_ERROR = "error",
        N = k.TOK_SUBTYPE_RANGE = "range",
        J = k.TOK_SUBTYPE_MATH = "math",
        S = k.TOK_SUBTYPE_CONCAT = "concatenate",
        R = k.TOK_SUBTYPE_INTERSECT = "intersect",
        K = k.TOK_SUBTYPE_UNION = "union";
    m.excelFormulaUtilities.isEu = "boolean" === typeof m.excelFormulaUtilities.isEu ? m.excelFormulaUtilities.isEu :
        !1;
    n.parseFormula = function(d, c) {
        var b = 0,
            e = document.getElementById(d),
            f = z(e.value),
            a;
        a = "<table cellspacing='0' style='border-top: 1px #cecece solid; margin-top: 5px; margin-bottom: 5px'><tr>";
        a += "<td class='token' style='font-weight: bold; width: 50px'>index</td>";
        a += "<td class='token' style='font-weight: bold; width: 125px'>type</td>";
        a += "<td class='token' style='font-weight: bold; width: 125px'>subtype</td>";
        a += "<td class='token' style='font-weight: bold; width: 150px'>token</td>";
        for (a += "<td class='token' style='font-weight: bold; width: 300px'>token tree</td></tr>"; f.moveNext();) {
            var h =
                f.current();
            h.subtype === u && (b -= 0 < b ? 1 : 0);
            a += "<tr>";
            a += "<td class='token'>" + (f.index + 1) + "</td>";
            a += "<td class='token'>" + h.type + "</td>";
            a += "<td class='token'>" + (0 === h.subtype.length ? "&nbsp;" : h.subtype.toString()) + "</td>";
            a += "<td class='token'>" + (0 === h.value.length ? "&nbsp;" : h.value).split(" ").join("&nbsp;") + "</td>";
            for (var g = "|", k = 0; k < b; k += 1) g += "&nbsp;&nbsp;&nbsp;|";
            a += "<td class='token'>" + g + (0 === h.value.length ? "&nbsp;" : h.value).split(" ").join("&nbsp;") + "</td>";
            a += "</tr>";
            h.subtype === v && (b += 1)
        }
        a += "</table>";
        document.getElementById(c).innerHTML = a;
        e.select();
        e.focus()
    };
    var U = n.toBase26 = function(d) {
            d = Math.abs(d);
            var c = "",
                b = !1,
                e;
            do e = d % 26, b && 25 > d && e--, c = String.fromCharCode(e + 65) + c, d = Math.floor((d - e) / 26), b = !0; while (0 < d);
            return c
        },
        F = n.fromBase26 = function(d) {
            d = d.toUpperCase();
            var c = 0,
                b = 0,
                e = 0;
            if (null !== d && "undefined" !== typeof d && 0 < d.length)
                for (; b < d.length; b++) c = d.charCodeAt(d.length - b - 1) - 65, e += Math.pow(26, b) * (c + 1);
            return e - 1
        },
        O = n.formatFormula = function(d, c) {
            d = d.replace(/^\s*=\s+/gi, "=");
            var b = {
                tmplFunctionStart: "{{autoindent}}{{token}}(\n",
                tmplFunctionStop: "\n{{autoindent}}{{token}})",
                tmplOperandError: " {{token}}",
                tmplOperandRange: "{{autoindent}}{{token}}",
                tmplOperandLogical: " {{token}}{{autolinebreak}}",
                tmplOperandNumber: "{{autoindent}}{{token}}",
                tmplOperandText: '{{autoindent}}"{{token}}"',
                tmplArgument: "{{token}}\n",
                tmplFunctionStartArray: "",
                tmplFunctionStartArrayRow: "{",
                tmplFunctionStopArrayRow: "}",
                tmplFunctionStopArray: "",
                tmplSubexpressionStart: "{{autoindent}}(\n",
                tmplSubexpressionStop: "\n)",
                tmplIndentTab: "\t",
                tmplIndentSpace: " ",
                autoLineBreak: "TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ",
                newLine: "\n",
                customTokenRender: null,
                prefix: "",
                postfix: ""
            };
            c = c ? t.extend(!0, b, c) : b;
            for (var e = 0, b = function() {
                    for (var a = "", b = 0; b < e; b += 1) a += c.tmplIndentTab;
                    return a
                }, f = z(d), a = "", h = c.autoLineBreak.replace(/\s/gi, "").split("|"), g = !0, l = function(a) {
                    for (var b = 0; b < h.length; b += 1)
                        if (null !== a && "undefined" !== typeof a && (k[h[b]] === a.type.toString() || k[h[b]] === a.subtype.toString())) return !0;
                    return !1
                }, n = null; f.moveNext();) {
                var m =
                    f.current(),
                    p = f.next();
                m.subtype.toString() === u && (e -= 0 < e ? 1 : 0);
                var q = new RegExp(c.newLine + "$", ""),
                    p = l(p),
                    g = g ? b() : c.tmplIndentSpace,
                    a = a + x(m, c, g, p ? c.newLine : "", c.customTokenRender, n);
                m.subtype.toString() === v && (e += 1);
                g = p || q.test(a);
                n = m
            }
            return a = c.prefix + r(a) + c.postfix
        };
    n.formatFormulaHTML = function(d) {
        return O(d, {
            tmplFunctionStart: '{{autoindent}}<span class="function">{{token}}</span><span class="function_start">(</span><br />',
            tmplFunctionStop: '<br />{{autoindent}}{{token}}<span class="function_stop">)</span>',
            tmplOperandError: "{{token}}",
            tmplOperandRange: "{{autoindent}}{{token}}",
            tmplOperandLogical: " {{token}}{{autolinebreak}}",
            tmplOperandNumber: "{{autoindent}}{{token}}",
            tmplOperandText: '{{autoindent}}<span class="quote_mark">"</span><span class="text">{{token}}</span><span class="quote_mark">"</span>',
            tmplArgument: "{{token}}<br />",
            tmplFunctionStartArray: "",
            tmplFunctionStartArrayRow: "{",
            tmplFunctionStopArrayRow: "}",
            tmplFunctionStopArray: "",
            tmplSubexpressionStart: "{{autoindent}}(",
            tmplSubexpressionStop: " )",
            tmplIndentTab: '<span class="tabbed">&nbsp;&nbsp;&nbsp;&nbsp;</span>',
            tmplIndentSpace: "&nbsp;",
            newLine: "<br />",
            autoLineBreak: "TOK_TYPE_FUNCTION | TOK_TYPE_ARGUMENT | TOK_SUBTYPE_LOGICAL | TOK_TYPE_OP_IN ",
            trim: !0,
            prefix: "=",
            customTokenRender: null
        })
    };
    var V = n.formula2CSharp = function(d) {
        //console.log(">>> d  ", d);
        var c = [];
        return O(d, {
            tmplFunctionStart: "{{token}}(",
            tmplFunctionStop: "{{token}})",
            tmplOperandError: "{{token}}",
            tmplOperandRange: "{{token}}",
            tmplOperandLogical: "{{token}}",
            tmplOperandNumber: "{{token}}",
            tmplOperandText: '"{{token}}"',
            tmplArgument: "{{token}}",
            tmplFunctionStartArray: "",
            tmplFunctionStartArrayRow: "{",
            tmplFunctionStopArrayRow: "}",
            tmplFunctionStopArray: "",
            tmplSubexpressionStart: "(",
            tmplSubexpressionStop: ")",
            tmplIndentTab: "\t",
            tmplIndentSpace: " ",
            autoLineBreak: "TOK_SUBTYPE_STOP | TOK_SUBTYPE_START | TOK_TYPE_ARGUMENT",
            trim: !0,
            customTokenRender: function(b, e, d, a) {
                d = "";
                a = {
                    "=": "==",
                    "<>": "!=",
                    MIN: "Math.Min",
                    MAX: "Math.Max",
                    ABS: "Math.ABS",
                    SUM: "",
                    IF: "",
                    "&": "+"
                };
				
                var h = c[c.length - 1],
                    g = !1;                
                
                switch (e.type.toString()) {
                    case s:
                        switch (e.subtype) {
                            case v:
                                //console.log("h.name ---   ", b);
                                c.push({
                                    name: b,
                                    argumentNumber: 0
                                });
                                d = "string" === typeof a[b.toUpperCase()] ? a[b.toUpperCase()] : b;
                                g = !0;
                                if(FR[d]) {
                                    d = "FR."+ d;
                                    //console.log("1111111h.name ---   ", d, "<<<<>>>>>>", typeof(d));
                                }                                
                                break;
                            case u:
                                g = !0;
                                switch (h.name.toLowerCase()) {
                                    case "if":
                                        d = ")";
                                        g = !1;
                                        break;
                                    default:
                                        d = "string" === typeof a[b.toUpperCase()] ? a[b.toUpperCase()] : b
                                }
                                c.pop()
                        }
                        break;
                    case E:                        
                        switch (h.name.toLowerCase()) {
                            case "if":
                                switch (h.argumentNumber) {
                                    case 0:
                                        d = "?";
                                        break;
                                    case 1:
                                        d = ":"
                                }
                                break;
                            case "sum":
                                d = "+";
                                break;
                            default:
                                d = "string" === typeof a[b.toUpperCase()] ? a[b.toUpperCase()] : b, g = !0
                        }
                        h.argumentNumber += 1;
                        break;
                    case p:                        
                        switch (e.subtype) {
                            case N:
								if(h && h.name){
                                switch (h.name.toLowerCase()) {
                                    case "sum":
                                        RegExp(":",
                                            "gi").test(b) ? d = l(b, "+") : outStr = b;
                                        break;
                                    default:
                                        
                                        //h.name = "FR."+h.name;                                        
                                        
                                        d = RegExp(":", "gi").test(b) ? "[" + l(b, ",") + "]" : b
                                        
                                }
								}
                                break
                        }
                    default:                        
                        "" === d && (d = "string" === typeof a[b.toUpperCase()] ? a[b.toUpperCase()] : b), g = !0
                }
                
                return {
                    tokenString: d,
                    useTemplate: g
                }
            }
        })
    };
    n.formula2JavaScript = function(d) {
        return V(d).replace("==", "===")
    };
    n.getTokens = z
})(formulaObj);

module.exports = formulaObj;